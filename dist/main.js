!function(e){var t={};function s(r){if(t[r])return t[r].exports;var n=t[r]={i:r,l:!1,exports:{}};return e[r].call(n.exports,n,n.exports,s),n.l=!0,n.exports}s.m=e,s.c=t,s.d=function(e,t,r){s.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},s.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},s.t=function(e,t){if(1&t&&(e=s(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(s.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var n in e)s.d(r,n,function(t){return e[t]}.bind(null,n));return r},s.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return s.d(t,"a",t),t},s.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},s.p="",s(s.s=9)}([function(e,t){e.exports=require("express")},function(e,t){e.exports=require("mongoose")},function(e,t){e.exports=require("bcryptjs")},function(e,t){e.exports=require("express-session")},function(e,t){e.exports=require("dotenv")},function(e,t){e.exports=require("body-parser")},function(e,t){e.exports=require("helmet")},function(e,t){e.exports=require("connect-mongo")},function(e,t){e.exports=require("shortid")},function(e,t,s){"use strict";s.r(t);var r=s(0),n=s.n(r),o=s(1),a=s.n(o),u=s(4),i=s.n(u),c=s(3),d=s.n(c),m=s(5),p=s.n(m),y=s(6),f=s.n(y),l=s(7),b=s.n(l);function h(e,t){let s=!1;switch(t){case"string":s="string"==typeof e;break;case"number":s="number"==typeof e&&!Number.isNaN(e);break;case"boolean":s="boolean"==typeof e;break;case"array":s=Array.isArray(e);break;case"object":s=e.constructor===Object;break;default:return"unknown type"}return s}function g(e,t){const s=[];return t.forEach(t=>{Object.prototype.hasOwnProperty.call(e,t)||s.push(t)}),{doesObjHaveRequiredProps:0===s.length,missingProps:s}}function q(e){let t="";switch(e.length){case 0:t="";break;case 1:t=`${e[0]}`;break;case 2:t=`${e[0]} and ${e[1]}`;break;default:for(let s=0;s<e.length-1;s+=1)t+=`${e[s]}, `;t+=`and ${e[e.length-1]}`}return t}function w(e,t){const{doesObjHaveRequiredProps:s,missingProps:r}=g(t,e);return{doesReqHaveRequiredParams:s,errorMessage:`${q(r)} ${1===r.length?"is":"are"} required`}}var x=s(8),j=s.n(x);const{Schema:I,model:v}=a.a,E=new I({name:{type:String,required:!0},type:{type:String,required:!0},options:[{type:String,required:!0}],answer:{type:String,required:!0}}),k=new I({_id:{type:String,default:j.a.generate},name:{type:String,required:!0},takenTest:{type:Boolean,required:!0},tookTest:Date,questionsTaken:[String],questionsCorrect:[String],questionsIncorrect:[String],score:String});var S=v("Exam",new I({creator:{type:String,required:!0},lastUpdated:{type:Date,required:!0},title:{type:String,required:!0},numberOfQuestions:{type:Number,required:!0},questions:[E],students:[k]}));async function T(e){return await S.findById(e)}function O(e){const t=Object.keys(e),s=[];return t.forEach(t=>{const r=e[t];switch(t){case"questionId":h(r,"string")||s.push("questionId must be a string");break;case"name":h(r,"string")||s.push("name must be a string");break;case"type":"radio"!==r&&"checkbox"!==r&&"true_false"!==r&&s.push("question type param must equal 'radio', 'checkbox', or 'true_false'");break;case"options":h(r,"array")||s.push("options must be an array");break;case"answer":h(r,"string")||s.push("answer must be a string");break;default:return t}return t}),{areQuestionParamsTheCorrectTypes:0===s.length,incorrectTypeParamErrsArr:s}}function R(e){const{type:t,options:s,answer:r}=e,n=[],o=[];"true_false"===t?("true"!==r&&"false"!==r&&n.push("answer must be 'true' or 'false'"),0!==s.length&&n.push("options must be an empty array")):(0===s.length&&o.push("options must not be a empty array"),s.includes(r)||o.push("options must include answer"));const a=new Set(n),u=new Set(o);return{doTrueOrFalseErrorsExist:0!==a.size,doRadioOrCheckBoxErrorsExist:0!==u.size,typeTrueOrFalseErrorsArr:[...a],typeRadioOrCheckBoxErrorsArr:[...u]}}function P(e){const t=[];Object.keys(e).forEach(s=>{const r=e[s];switch(s){case"name":h(r,"string")||t.push("name must be a string");break;case"takenTest":h(r,"boolean")||t.push("takenTest must be an boolean");break;case"studentId":h(r,"string")||t.push("studentId must be a string");break;case"questionsTaken":h(r,"array")||t.push("questionsTaken must be an array");break;case"questionsCorrect":h(r,"array")||t.push("questionsCorrect must be an array");break;case"questionsIncorrect":h(r,"array")||t.push("questionsIncorrect must be an array");break;default:return s}return s});const s=[...new Set(t)];return{doesStudentHaveCorrectTypes:0===t.length,incorrectTypeParamErrsArr:s}}async function A(e,t,s){const{examId:r}=e.params;await async function(e){let t=!1;try{t=1===await S.countDocuments({_id:e})}catch(e){t=!1}return t}(r)?s():(t.status(400),t.json({error:"invalid examId"}))}const $=n.a.Router();$.route("/").post((function(e,t,s){const{doesReqHaveRequiredParams:r,errorMessage:n}=w(["creator","title"],e.body);r?s():(t.status(400),t.json({error:n}))}),(function(e,t,s){const r=Object.keys(e.body),n=[];r.forEach(t=>{const s=e.body[t];switch(t){case"creator":h(s,"string")||n.push("creator must be a string");break;case"title":h(s,"string")||n.push("title must be a string");break;case"questions":h(s,"array")||n.push("questions must be a array");break;case"students":h(s,"array")||n.push("students must be a array");break;default:return t}}),0===n.length?s():(t.status(400),t.json({error:q(n)}))}),(function(e,t,s){const{questions:r}=e.body;r.every(e=>h(e,"object"))?s():(t.status(400),t.json({error:"questions must be an array of objects"}))}),(function(e,t,s){const{students:r}=e.body;r.every(e=>h(e,"object"))?s():(t.status(400),t.json({error:"students must be an array of objects"}))}),(function(e,t,s){const{questions:r}=e.body;r.every(e=>(function(e){const{doesObjHaveRequiredProps:t}=g(e,["name","type","options","answer"]);return t})(e))?s():(t.status(400),t.json({error:"each question element must have a name, type, options, and answer property"}))}),(function(e,t,s){const{students:r}=e.body;r.every(e=>(function(e){const{doesObjHaveRequiredProps:t}=g(e,["name"]);return t})(e))?s():(t.status(400),t.json({error:"each student element must have a name property"}))}),(function(e,t,s){const{questions:r}=e.body,n=[];if(r.forEach(e=>{const{areQuestionParamsTheCorrectTypes:t,incorrectTypeParamErrsArr:s}=O(e);t||n.push(...s)}),0===n.length)s();else{const e=new Set(n);t.status(400),t.json({error:`questions' param values must be correct types: ${q([...e])}`})}}),(function(e,t,s){const{students:r}=e.body,n=[];if(r.forEach(e=>{const{doesStudentHaveCorrectTypes:t,incorrectTypeParamErrsArr:s}=P(e);return t||n.push(...s),e}),0===n.length)s();else{const e=new Set(n);t.status(400),t.json({error:`students' param values must be correct types: ${q([...e])}`})}}),(function(e,t,s){const{questions:r}=e.body,n=[],o=[],a=[];if(r.forEach(e=>{const{doTrueOrFalseErrorsExist:t,doRadioOrCheckBoxErrorsExist:s,typeTrueOrFalseErrorsArr:r,typeRadioOrCheckBoxErrorsArr:n}=R(e);t&&o.push(...r),s&&a.push(...n)}),0!==o.length){const e=new Set(o);n.push(`for true_false type, ${q([...e])}`)}if(0!==a.length){const e=new Set(a);n.push(`for radio or checkbox type, ${q([...e])}`)}if(0===n.length)s();else{const e=new Set(n);t.status(400),t.json({error:`questions' params must have correct values for type: ${q([...e])}`})}}),(async function(e,t){const{title:s,creator:r,questions:n,students:o}=e.body,a=n.map(e=>{const{name:t,type:s,options:r,answer:n}=e;return{name:t,type:s,options:r,answer:n}}),u=o.map(e=>{const{name:t}=e;return{name:t,takenTest:!1}}),i={title:s,creator:r,lastUpdated:Date.now(),numberOfQuestions:n.length,questions:a,students:u},c=await new S(i).save().catch(()=>{t.status(501),t.json({error:"could not create exam"})});t.status(201),t.json({message:"exam created",exam:c})})),$.route("/:examId").get(A,(async function(e,t){const{examId:s}=e.params,r=await T(s);t.status(200),t.json({message:"exam found",exam:r})})).put(A,(function(e,t,s){const{doesReqHaveRequiredParams:r,errorMessage:n}=w(["title"],e.body);r?s():(t.status(400),t.json({error:n}))}),(function(e,t,s){const{title:r}=e.body;h(r,"string")?s():(t.status(400),t.json({error:"title must be a string"}))}),(async function(e,t){const{examId:s}=e.params,{title:r}=e.body,n=await S.findByIdAndUpdate(s,{$set:{title:r,lastUpdated:Date.now()}},{new:!0,useFindAndModify:!1});t.status(200),t.json({message:"exam title updated",updatedExam:n})})).delete(A,(async function(e,t){const{examId:s}=e.params;await S.findByIdAndDelete(s),t.status(200),t.json({message:"exam deleted"})}));var C=$;async function _(e,t,s){const{examId:r}=e.params,{questionId:n}=e.body;await async function(e,t){return(await S.findById(e)).questions.some(e=>e._id==t)}(r,n)?s():(t.status(400),t.json({error:"invalid questionId"}))}function M(e,t,s){const{areQuestionParamsTheCorrectTypes:r,incorrectTypeParamErrsArr:n}=O(e.body);r?s():(t.status(400),t.json({error:q(n)}))}const B=n.a.Router();B.route("/:examId").post(A,(function(e,t,s){const{doesReqHaveRequiredParams:r,errorMessage:n}=w(["name","type","options","answer"],e.body);r?s():(t.status(400),t.json({error:n}))}),M,(function(e,t,s){const{doTrueOrFalseErrorsExist:r,doRadioOrCheckBoxErrorsExist:n,typeTrueOrFalseErrorsArr:o,typeRadioOrCheckBoxErrorsArr:a}=R(e.body);if(r||n){const e=r?`for a question with a true_false type, ${q([...o])}`:`for a question with a radio or checkbox type, ${q([...a])}`;t.status(400),t.json({error:e})}else s()}),(async function(e,t){const{examId:s}=e.params,{name:r,type:n,options:o,answer:a}=e.body,u={name:r,type:n,options:o,answer:a},i=await S.findByIdAndUpdate(s,{$push:{questions:u},$inc:{numberOfQuestions:1},$set:{lastUpdated:Date.now()}},{useFindAndModify:!1,new:!0});t.status(201),t.json({message:"question added to exam",updatedExam:i})})).put(A,_,(function(e,t,s){[["questionId","name"],["questionId","type"],["questionId","options"],["questionId","answer"]].some(t=>{const{doesReqHaveRequiredParams:s}=w(t,e.body);return s})?s():(t.status(400),t.json({error:"questionId and at least one param(type, options, name, or answer) to be changed is required"}))}),M,(async function(e,t,s){const{examId:r}=e.params,{questionId:n}=e.body,o=await async function(e,t){return(await S.findById(e)).questions.find(e=>e._id==t)}(r,n),a={};["name","type","options","answer"].forEach(t=>(a[t]=e.body[t]?e.body[t]:o[t],t));const{doTrueOrFalseErrorsExist:u,doRadioOrCheckBoxErrorsExist:i,typeTrueOrFalseErrorsArr:c,typeRadioOrCheckBoxErrorsArr:d}=R(a);if(u||i){const e=u?`for a question with a true_false type, ${q([...c])}`:`for a question with a radio or checkbox type, ${q([...d])}`;t.status(400),t.json({error:e})}else s()}),(async function(e,t){const s=await T(e.params.examId),r=s.questions.id(e.body.questionId);["name","type","options","answer"].forEach(t=>{r[t]=e.body[t]?e.body[t]:r[t]}),await s.save();const n=await S.findByIdAndUpdate(s._id,{$set:{lastUpdated:Date.now()}},{useFindAndModify:!1,new:!0});t.status(200),t.json({message:"question edited",updatedExam:n})})).delete(A,_,(async function(e,t){const{examId:s}=e.params,r=await T(e.params.examId);r.questions.id(e.body.questionId).remove(),await r.save(),await S.findByIdAndUpdate(s,{$inc:{numberOfQuestions:-1},$set:{lastUpdated:Date.now()}},{useFindAndModify:!1,new:!0}),t.status(200),t.json({message:"question deleted"})}));var H=B;async function U(e,t,s){const{examId:r}=e.params,{studentId:n}=e.body;await async function(e,t){return(await S.findById(e)).students.some(e=>e._id==t)}(r,n)?s():(t.status(400),t.json({error:"invalid studentId"}))}const F=n.a.Router();F.route("/:examId").post(A,(function(e,t,s){const{doesReqHaveRequiredParams:r,errorMessage:n}=w(["name"],e.body);r?s():(t.status(400),t.json({error:n}))}),(function(e,t,s){const{doesStudentHaveCorrectTypes:r,incorrectTypeParamErrsArr:n}=P(e.body);r?s():(t.status(400),t.json({error:`${q(n)}`}))}),(async function(e,t){const{examId:s}=e.params,{name:r}=e.body,n={name:r,takenTest:!1},o=await S.findByIdAndUpdate(s,{$push:{students:n}},{useFindAndModify:!1,new:!0});t.status(201),t.json({message:"student added",updatedExam:o})})).put(A,U,(function(e,t,s){const{doesReqHaveRequiredParams:r,errorMessage:n}=w(["studentId","name"],e.body);r?s():(t.status(400),t.json({error:n}))}),(function(e,t,s){const{name:r}=e.body;h(r,"string")?s():(t.status(400),t.json({error:"name must be a string"}))}),(async function(e,t){const s=await T(e.params.examId),r=s.students.id(e.body.studentId);r.name=e.body.name?e.body.name:r.name,await s.save(),t.status(200),t.json({message:"student name edited",updatedExam:s})})).delete(A,U,(async function(e,t){const s=await T(e.params.examId);s.students.id(e.body.studentId).remove(),await s.save(),t.status(200),t.json({message:"student deleted",updatedExam:s})})),F.route("/save-exam-results/:examId").put(A,(function(e,t,s){const{doesReqHaveRequiredParams:r,errorMessage:n}=w(["studentId","questionsCorrect","questionsIncorrect"],e.body);r?s():(t.status(400),t.json({error:n}))}),U,(function(e,t,s){const{questionsIncorrect:r,questionsCorrect:n}=e.body,o={questionsIncorrect:r,questionsCorrect:n},{doesStudentHaveCorrectTypes:a,incorrectTypeParamErrsArr:u}=P(o);a?s():(t.status(400),t.json({error:q(u)}))}),(async function(e,t,s){const r=[],{questionsIncorrect:n,questionsCorrect:o}=e.body,a=(await T(e.params.examId)).questions.map(e=>e._id).sort();[...n,...o].sort().join("")!==a.join("")&&r.push("questionsIncorrect must contain the questionIds of the questions that the student got incorrect and questionsCorrect must contain the questionIds of the questions that the student got correct"),0===r.length?s():(t.status(400),t.json({error:q(r)}))}),(async function(e,t){const{studentId:s,questionsCorrect:r,questionsIncorrect:n}=e.body,o=await T(e.params.examId),a=o.students.id(s);a.questionsCorrect=r,a.questionsIncorrect=n,a.questionsTaken=[...n,...r],a.takenTest=!0,await o.save(),t.status(200),t.json({message:"exam results saved",updatedExam:o})}));var D=F,N=s(2),Q=s.n(N);const z=new a.a.Schema({username:{type:String,required:!0},email:{type:String,required:!0,validate:{validator:e=>Z.doesNotExist({email:e}),message:"Email already exists"}},password:{type:String,required:!0}},{timestamps:!0});z.statics.doesNotExist=async function(e){return 0===await this.where(e).countDocuments()};const Z=a.a.model("User",z);var L=Z;const{SESS_NAME:V}=process.env;async function G(e){let t=!1;try{t=1===await L.countDocuments({email:e})}catch(e){t=!1}return t}function J(e,t,s){const{session:{user:r}}=e;r?(t.status(400),t.json({error:"a user is already logged in"})):s()}function K(e,t,s){const{session:{user:r}}=e;r?s():(t.status(401),t.json({error:"user is not logged in"}))}const W=n.a.Router();W.route("/").get(K,(async function(e,t){const{session:{user:{userId:s}}}=e,r=await L.findById(s);t.json({message:"user found",user:r})})).delete(K,(async function(e,t){const{session:s}=e,{user:{userId:r}}=s;try{await L.findByIdAndRemove(r,{useFindAndModify:!1}),await S.deleteMany({creator:r}),s.destroy(()=>{t.clearCookie(V),t.status(200),t.json({message:"user deleted",userId:r})})}catch(e){t.status(501),t.json({error:"could not delete user"})}})),W.route("/signup").post(J,(function(e,t,s){const{doesReqHaveRequiredParams:r,errorMessage:n}=w(["email","username","password"],e.body);r?s():(t.status(400),t.json({error:n}))}),(function(e,t,s){const r=[];["username","email","password"].forEach(t=>{h(e.body[t],"string")||r.push(`${t} must be a string`)}),0===r.length?s():(t.status(400),t.json({error:q(r)}))}),(function(e,t,s){const{areReqParamsEmpty:r,errorMessage:n}=function(e,t){const s=[];return e.forEach(e=>{0===t[e].length&&s.push(e)}),{areReqParamsEmpty:0!==s.length,errorMessage:`${q(s)} must not be empty`}}(["username","email","password"],e.body);r?(t.status(400),t.json({error:n})):s()}),(async function(e,t,s){const{email:r}=e.body;await G(r)?(t.status(400),t.json({error:"email already exists"})):s()}),(function(e,t,s){const{username:r}=e.body,n=[];/\S/g.test(r)||n.push("must not contain only whitespace"),r.length>15&&n.push("must not exceed 15 characters"),0===n.length?s():(t.status(400),t.json({error:`username ${q(n)}`}))}),(function(e,t,s){const{email:r}=e.body;/^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/.test(r)?s():(t.status(400),t.json({error:"invalid email"}))}),(function(e,t,s){const{password:r}=e.body,n=[];/\s/g.test(r)&&n.push("must not contain any whitespace"),r.length<8&&n.push("length must be at least 8 characters"),r.length>50&&n.push("length must not exceed 50 characters"),0===n.length?s():(t.status(400),t.json({error:`password ${q(n)}`}))}),(async function(e,t){const{username:s,email:r,password:n}=e.body,o={username:s,email:r,password:await Q.a.hash(n,10)};try{const s=await new L(o).save();e.session.user={userId:s._id},t.status(201),t.json({message:"user added",newUser:s})}catch(e){t.status(501),t.json({error:"could not add user"})}})),W.route("/login").post(J,(function(e,t,s){const{doesReqHaveRequiredParams:r,errorMessage:n}=w(["email","password"],e.body);r?s():(t.status(400),t.json({error:n}))}),(async function(e,t,s){const{email:r}=e.body;await G(r)?s():(t.status(400),t.json({error:"email not found in database"}))}),(async function(e,t,s){const{email:r,password:n}=e.body,o=await L.findOne({email:r});await Q.a.compare(n,o.password)?s():(t.status(400),t.json({error:"password is incorrect"}))}),(async function(e,t){const{email:s}=e.body;try{const r=await L.findOne({email:s});e.session.user={userId:r._id},t.status(200),t.json({message:"user logged in",user:r})}catch(e){t.status(501),t.json({error:"could not login user"})}})),W.route("/logout").post(K,(function(e,t){const{session:s}=e,{user:{userId:r}}=s;s.destroy(e=>{e?(t.status(500),t.json({error:"something went wrong"})):(t.clearCookie(V),t.status(200),t.json({message:"user logged out",userId:r}))})})),W.route("/exams").get(K,(async function(e,t){const{session:{user:{userId:s}}}=e;try{const e=await S.find({creator:s});t.status(200),t.json({message:"exams found",exams:e})}catch(e){t.status(501),t.json({error:"could not get exams"})}}));var X=W;i.a.config();const{SESS_NAME:Y,SESS_SECRET:ee,SESS_LIFETIME:te,DB:se,NODE_ENV:re}=process.env,ne=n()();ne.use(f()());const oe=se;a.a.connect(oe,{dbName:"exam-creator",useNewUrlParser:!0,useUnifiedTopology:!0}),ne.use(p.a.json());const ae=b()(d.a);ne.use(d()({name:Y,secret:ee,saveUninitialized:!1,resave:!1,store:new ae({mongooseConnection:a.a.connection,ttl:parseInt(te,10)/1e3}),cookie:{sameSite:!0,secure:"production"===re,maxAge:parseInt(te,10)}})),ne.use("/api/v1/exams",C),ne.use("/api/v1/exams/questions",H),ne.use("/api/v1/exams/students",D),ne.use("/api/v1/users",X);var ue=ne;const ie=process.env.PORT||8080;ue.listen(ie);t.default=ue}]);