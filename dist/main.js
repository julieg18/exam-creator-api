!function(e){var t={};function s(n){if(t[n])return t[n].exports;var o=t[n]={i:n,l:!1,exports:{}};return e[n].call(o.exports,o,o.exports,s),o.l=!0,o.exports}s.m=e,s.c=t,s.d=function(e,t,n){s.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},s.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},s.t=function(e,t){if(1&t&&(e=s(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(s.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)s.d(n,o,function(t){return e[t]}.bind(null,o));return n},s.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return s.d(t,"a",t),t},s.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},s.p="",s(s.s=9)}([function(e,t){e.exports=require("express")},function(e,t){e.exports=require("mongoose")},function(e,t){e.exports=require("bcryptjs")},function(e,t){e.exports=require("express-session")},function(e,t){e.exports=require("dotenv")},function(e,t){e.exports=require("body-parser")},function(e,t){e.exports=require("helmet")},function(e,t){e.exports=require("connect-mongo")},function(e,t){e.exports=require("shortid")},function(e,t,s){"use strict";s.r(t);var n=s(0),o=s.n(n),r=s(1),a=s.n(r),u=s(4),i=s.n(u),c=s(3),d=s.n(c),p=s(5),m=s.n(p),y=s(6),f=s.n(y),l=s(7),b=s.n(l);function h(e,t){let s=!1;switch(t){case"string":s="string"==typeof e;break;case"number":s="number"==typeof e&&!Number.isNaN(e);break;case"boolean":s="boolean"==typeof e;break;case"array":s=Array.isArray(e);break;case"object":s=e.constructor===Object;break;default:return"unknown type"}return s}function g(e,t){const s=[];return t.forEach(t=>{Object.prototype.hasOwnProperty.call(e,t)||s.push(t)}),{doesObjHaveRequiredProps:0===s.length,missingProps:s}}function q(e){let t="";switch(e.length){case 0:t="";break;case 1:t=`${e[0]}`;break;case 2:t=`${e[0]} and ${e[1]}`;break;default:for(let s=0;s<e.length-1;s+=1)t+=`${e[s]}, `;t+=`and ${e[e.length-1]}`}return t}function w(e,t){const{doesObjHaveRequiredProps:s,missingProps:n}=g(t,e);return{doesReqHaveRequiredParams:s,errorMessage:`${q(n)} ${1===n.length?"is":"are"} required`}}function j(e,t){const s=[];return e.forEach(e=>{0===t[e].length&&s.push(e)}),{areReqParamsEmpty:0!==s.length,errorMessage:`${q(s)} must not be empty`}}function I(e){const t=e.split("");return t[0]=t[0].toUpperCase(),t.push("."),t.join("")}var v=s(8),x=s.n(v);const{Schema:k,model:S}=a.a,E=new k({name:{type:String,required:!0},optionId:{type:String,required:!0}}),P=new k({name:{type:String,required:!0},type:{type:String,required:!0},options:[E],answer:[{type:String,required:!0}]}),R=new k({_id:{type:String,default:x.a.generate},name:{type:String,required:!0},takenTest:{type:Boolean,required:!0},tookTest:Date,questionsTaken:[String],questionsCorrect:[String],questionsIncorrect:[String],score:String});var T=S("Exam",new k({creator:{type:String,required:!0},lastUpdated:{type:Date,required:!0},title:{type:String,required:!0},numberOfQuestions:{type:Number,required:!0},questions:[P],students:[R]}));async function $(e){return await T.findById(e)}function A(e){const t=Object.keys(e),s=[];return t.forEach(t=>{const n=e[t];switch(t){case"questionId":h(n,"string")||s.push("questionId must be a string");break;case"name":h(n,"string")||s.push("name must be a string");break;case"type":"radio"!==n&&"checkbox"!==n&&"true_false"!==n&&s.push("question type param must equal 'radio', 'checkbox', or 'true_false'");break;case"options":h(n,"array")||s.push("options must be an array");break;case"answer":h(n,"array")||s.push("answer must be a array");break;default:return t}return t}),{areQuestionParamsTheCorrectTypes:0===s.length,incorrectTypeParamErrsArr:s}}function O(e){const{options:t,answer:s}=e,n=[];return"true"!==s[0]&&"false"!==s[0]&&n.push("answer must contain a value of 'true' or 'false'"),0!==t.length&&n.push("options must be an empty array"),n}function C(e){const{options:t,answer:s}=e,n=[],o=t.every(e=>h(e,"object")),r=t.every(e=>g(e,["name","optionId"]).doesObjHaveRequiredProps),a=t.every(e=>h(e.name,"string")),u=t.every(e=>h(e.optionId,"string")),i=t.map(e=>e.optionId),c=new Set(i),d=i.length===c.size,p=t.some(e=>e.optionId===s[0]);return 0===t.length&&n.push("options must not be an empty array"),o&&r||n.push("options must be filled with objects(each object containing a name property and a optionId property)"),a||n.push("the options name properties must be strings"),u&&d||n.push("the options optionId properties must be unique strings"),p||n.push("the options answer property must contain one optionId"),n}function M(e){const{options:t,answer:s}=e,n=[],o=t.every(e=>h(e,"object")),r=t.every(e=>g(e,["name","optionId"]).doesObjHaveRequiredProps),a=t.every(e=>h(e.name,"string")),u=t.every(e=>h(e.optionId,"string")),i=t.map(e=>e.optionId),c=new Set(i),d=i.length===c.size,p=s.every(e=>t.some(t=>t.optionId===e));return 0===t.length&&n.push("options must not be an empty array"),o&&r||n.push("options must be filled with objects, each object containing a name property and a optionId property"),a||n.push("the options name properties must be strings"),u&&d||n.push("the options optionId properties must be unique strings"),p||n.push("the options answer property must be filled with at least one optionId"),n}function _(e){const t=[];Object.keys(e).forEach(s=>{const n=e[s];switch(s){case"name":h(n,"string")||t.push("name must be a string");break;case"takenTest":h(n,"boolean")||t.push("takenTest must be an boolean");break;case"studentId":h(n,"string")||t.push("studentId must be a string");break;case"questionsTaken":h(n,"array")||t.push("questionsTaken must be an array");break;case"questionsCorrect":h(n,"array")||t.push("questionsCorrect must be an array");break;case"questionsIncorrect":h(n,"array")||t.push("questionsIncorrect must be an array");break;default:return s}return s});const s=[...new Set(t)];return{doesStudentHaveCorrectTypes:0===t.length,incorrectTypeParamErrsArr:s}}async function U(e,t,s){const{examId:n}=e.params;await async function(e){let t=!1;try{t=1===await T.countDocuments({_id:e})}catch(e){t=!1}return t}(n)?s():(t.status(400),t.json({error:"invalid examId"}))}const H=o.a.Router();H.route("/").post((function(e,t,s){const{doesReqHaveRequiredParams:n,errorMessage:o}=w(["creator","title","questions","students"],e.body);n?s():(t.status(400),t.json({error:o}))}),(function(e,t,s){const n=Object.keys(e.body),o=[];n.forEach(t=>{const s=e.body[t];switch(t){case"creator":h(s,"string")||o.push("creator must be a string");break;case"title":h(s,"string")||o.push("title must be a string");break;case"questions":h(s,"array")||o.push("questions must be a array");break;case"students":h(s,"array")||o.push("students must be a array");break;default:return t}}),0===o.length?s():(t.status(400),t.json({error:q(o)}))}),(function(e,t,s){const{questions:n}=e.body;n.every(e=>h(e,"object"))?s():(t.status(400),t.json({error:"questions must be an array of objects"}))}),(function(e,t,s){const{students:n}=e.body;n.every(e=>h(e,"object"))?s():(t.status(400),t.json({error:"students must be an array of objects"}))}),(function(e,t,s){const{questions:n}=e.body;n.every(e=>(function(e){const{doesObjHaveRequiredProps:t}=g(e,["name","type","options","answer"]);return t})(e))?s():(t.status(400),t.json({error:"each question element must have a name, type, options, and answer property"}))}),(function(e,t,s){const{students:n}=e.body;n.every(e=>(function(e){const{doesObjHaveRequiredProps:t}=g(e,["name"]);return t})(e))?s():(t.status(400),t.json({error:"each student element must have a name property"}))}),(function(e,t,s){const{questions:n}=e.body,o=[];if(n.forEach(e=>{const{areQuestionParamsTheCorrectTypes:t,incorrectTypeParamErrsArr:s}=A(e);t||o.push(...s)}),0===o.length)s();else{const e=new Set(o);t.status(400),t.json({error:`questions' param values must be correct types: ${q([...e])}`})}}),(function(e,t,s){const{students:n}=e.body,o=[];if(n.forEach(e=>{const{doesStudentHaveCorrectTypes:t,incorrectTypeParamErrsArr:s}=_(e);return t||o.push(...s),e}),0===o.length)s();else{const e=new Set(o);t.status(400),t.json({error:`students' param values must be correct types: ${q([...e])}`})}}),(function(e,t,s){const{questions:n}=e.body,o=[],r=[],a=[],u=[];if(n.forEach(e=>{switch(e.type){case"true_false":r.push(...O(e));break;case"checkbox":a.push(...M(e));break;case"radio":u.push(...C(e))}}),0!==r.length){const e=new Set(r);o.push(`for true_false type, ${q([...e])}`)}if(0!==u.length){const e=new Set(u);o.push(`for radio type, ${q([...e])}`)}if(0!==a.length){const e=new Set(a);o.push(`for checkbox type, ${q([...e])}`)}if(0===o.length)s();else{const e=new Set(o);t.status(400),t.json({error:`questions' params must have correct values for type: ${q([...e])}`})}}),(async function(e,t){const{title:s,creator:n,questions:o,students:r}=e.body,a=o.map(e=>{const{name:t,type:s,options:n,answer:o}=e;return{name:t,type:s,options:n.map(e=>({name:e.name,optionId:e.optionId})),answer:o}}),u=r.map(e=>{const{name:t}=e;return{name:t,takenTest:!1}}),i={title:s,creator:n,lastUpdated:Date.now(),numberOfQuestions:o.length,questions:a,students:u},c=await new T(i).save().catch(()=>{t.status(501),t.json({error:"could not create exam"})});t.status(201),t.json({message:"exam created",exam:c})})),H.route("/:examId").get(U,(async function(e,t){const{examId:s}=e.params,n=await $(s);t.status(200),t.json({message:"exam found",exam:n})})).put(U,(function(e,t,s){const{doesReqHaveRequiredParams:n,errorMessage:o}=w(["title"],e.body);n?s():(t.status(400),t.json({error:o}))}),(function(e,t,s){const{title:n}=e.body;h(n,"string")?s():(t.status(400),t.json({error:"title must be a string"}))}),(async function(e,t){const{examId:s}=e.params,{title:n}=e.body,o=await T.findByIdAndUpdate(s,{$set:{title:n,lastUpdated:Date.now()}},{new:!0,useFindAndModify:!1});t.status(200),t.json({message:"exam title updated",updatedExam:o})})).delete(U,(async function(e,t){const{examId:s}=e.params;await T.findByIdAndDelete(s),t.status(200),t.json({message:"exam deleted"})}));var B=H;async function D(e,t,s){const{examId:n}=e.params,{questionId:o}=e.body;await async function(e,t){return(await T.findById(e)).questions.some(e=>e._id==t)}(n,o)?s():(t.status(400),t.json({error:"invalid questionId"}))}function N(e,t,s){const{areQuestionParamsTheCorrectTypes:n,incorrectTypeParamErrsArr:o}=A(e.body);n?s():(t.status(400),t.json({error:q(o)}))}const F=o.a.Router();F.route("/:examId").post(U,(function(e,t,s){const{doesReqHaveRequiredParams:n,errorMessage:o}=w(["name","type","options","answer"],e.body);n?s():(t.status(400),t.json({error:o}))}),N,(function(e,t,s){let n=[];switch(e.body.type){case"checkbox":n=[...M(e.body)];break;case"radio":n=[...C(e.body)];break;case"true_false":n=[...O(e.body)]}if(0===n.length)s();else{const s=`for a question with a ${e.body.type} type: ${q(n)}`;t.status(400),t.json({error:s})}}),(async function(e,t){const{examId:s}=e.params,{name:n,type:o,options:r,answer:a}=e.body,u={name:n,type:o,options:r,answer:a},i=await T.findByIdAndUpdate(s,{$push:{questions:u},$inc:{numberOfQuestions:1},$set:{lastUpdated:Date.now()}},{useFindAndModify:!1,new:!0});t.status(201),t.json({message:"question added to exam",updatedExam:i})})).put(U,D,(function(e,t,s){[["questionId","name"],["questionId","type"],["questionId","options"],["questionId","answer"]].some(t=>{const{doesReqHaveRequiredParams:s}=w(t,e.body);return s})?s():(t.status(400),t.json({error:"questionId and at least one param(type, options, name, or answer) to be changed is required"}))}),N,(async function(e,t,s){const{examId:n}=e.params,{questionId:o}=e.body;let r=await async function(e,t){return(await T.findById(e)).questions.find(e=>e._id==t)}(n,o);r=r.toObject();const a={};["name","type","options","answer"].forEach(t=>(a[t]=e.body[t]?e.body[t]:r[t],t));let u=[];switch(a.type){case"checkbox":u=[...M(a)];break;case"radio":u=[...C(a)];break;case"true_false":u=[...O(a)]}if(0===u.length)s();else{const e=`for a question with a ${a.type} type: ${q(u)}`;t.status(400),t.json({error:e})}}),(async function(e,t){const s=await $(e.params.examId),n=s.questions.id(e.body.questionId);["name","type","options","answer"].forEach(t=>{n[t]=e.body[t]?e.body[t]:n[t]}),await s.save();const o=await T.findByIdAndUpdate(s._id,{$set:{lastUpdated:Date.now()}},{useFindAndModify:!1,new:!0});t.status(200),t.json({message:"question edited",updatedExam:o})})).delete(U,D,(async function(e,t){const{examId:s}=e.params,n=await $(e.params.examId);n.questions.id(e.body.questionId).remove(),await n.save(),await T.findByIdAndUpdate(s,{$inc:{numberOfQuestions:-1},$set:{lastUpdated:Date.now()}},{useFindAndModify:!1,new:!0}),t.status(200),t.json({message:"question deleted"})}));var Q=F;async function z(e,t,s){const{examId:n}=e.params,{studentId:o}=e.body;await async function(e,t){return(await T.findById(e)).students.some(e=>e._id==t)}(n,o)?s():(t.status(400),t.json({error:"invalid studentId"}))}const Z=o.a.Router();Z.route("/:examId").post(U,(function(e,t,s){const{doesReqHaveRequiredParams:n,errorMessage:o}=w(["name"],e.body);n?s():(t.status(400),t.json({error:o}))}),(function(e,t,s){const{doesStudentHaveCorrectTypes:n,incorrectTypeParamErrsArr:o}=_(e.body);n?s():(t.status(400),t.json({error:`${q(o)}`}))}),(async function(e,t){const{examId:s}=e.params,{name:n}=e.body,o={name:n,takenTest:!1},r=await T.findByIdAndUpdate(s,{$push:{students:o}},{useFindAndModify:!1,new:!0});t.status(201),t.json({message:"student added",updatedExam:r})})).put(U,z,(function(e,t,s){const{doesReqHaveRequiredParams:n,errorMessage:o}=w(["studentId","name"],e.body);n?s():(t.status(400),t.json({error:o}))}),(function(e,t,s){const{name:n}=e.body;h(n,"string")?s():(t.status(400),t.json({error:"name must be a string"}))}),(async function(e,t){const s=await $(e.params.examId),n=s.students.id(e.body.studentId);n.name=e.body.name?e.body.name:n.name,await s.save(),t.status(200),t.json({message:"student name edited",updatedExam:s})})).delete(U,z,(async function(e,t){const s=await $(e.params.examId);s.students.id(e.body.studentId).remove(),await s.save(),t.status(200),t.json({message:"student deleted",updatedExam:s})})),Z.route("/save-exam-results/:examId").put(U,(function(e,t,s){const{doesReqHaveRequiredParams:n,errorMessage:o}=w(["studentId","questionsCorrect","questionsIncorrect"],e.body);n?s():(t.status(400),t.json({error:o}))}),z,(function(e,t,s){const{questionsIncorrect:n,questionsCorrect:o}=e.body,r={questionsIncorrect:n,questionsCorrect:o},{doesStudentHaveCorrectTypes:a,incorrectTypeParamErrsArr:u}=_(r);a?s():(t.status(400),t.json({error:q(u)}))}),(async function(e,t,s){const n=[],{questionsIncorrect:o,questionsCorrect:r}=e.body,a=(await $(e.params.examId)).questions.map(e=>e._id).sort();[...o,...r].sort().join("")!==a.join("")&&n.push("questionsIncorrect must contain the questionIds of the questions that the student got incorrect and questionsCorrect must contain the questionIds of the questions that the student got correct"),0===n.length?s():(t.status(400),t.json({error:q(n)}))}),(async function(e,t){const{studentId:s,questionsCorrect:n,questionsIncorrect:o}=e.body,r=await $(e.params.examId),a=r.students.id(s);a.questionsCorrect=n,a.questionsIncorrect=o,a.questionsTaken=[...o,...n],a.takenTest=!0,await r.save(),t.status(200),t.json({message:"exam results saved",updatedExam:r})}));var L=Z,V=s(2),G=s.n(V);const J=new a.a.Schema({username:{type:String,required:!0},email:{type:String,required:!0,validate:{validator:e=>K.doesNotExist({email:e}),message:"Email already exists"}},password:{type:String,required:!0}},{timestamps:!0});J.statics.doesNotExist=async function(e){return 0===await this.where(e).countDocuments()};const K=a.a.model("User",J);var W=K;const{SESS_NAME:X}=process.env;async function Y(e){let t=!1;try{t=1===await W.countDocuments({email:e})}catch(e){t=!1}return t}function ee(e,t,s){const{session:{user:n}}=e;n?(t.status(400),t.json({error:"A user is already logged in."})):s()}function te(e,t,s){const{session:{user:n}}=e;n?s():(t.status(401),t.json({error:"User is not logged in."}))}const se=o.a.Router();se.route("/").get(te,(async function(e,t){const{session:{user:{userId:s}}}=e,n=await W.findById(s);t.json({message:"User found.",user:n})})).delete(te,(async function(e,t){const{session:s}=e,{user:{userId:n}}=s;try{await W.findByIdAndRemove(n,{useFindAndModify:!1}),await T.deleteMany({creator:n}),s.destroy(()=>{t.clearCookie(X),t.status(200),t.json({message:"User deleted.",userId:n})})}catch(e){t.status(501),t.json({error:"Could not delete user."})}})),se.route("/signup").post(ee,(function(e,t,s){const{doesReqHaveRequiredParams:n,errorMessage:o}=w(["email","username","password"],e.body);n?s():(t.status(400),t.json({error:I(o)}))}),(function(e,t,s){const n=[];["username","email","password"].forEach(t=>{h(e.body[t],"string")||n.push(`${t} must be a string`)}),0===n.length?s():(t.status(400),t.json({error:I(q(n))}))}),(function(e,t,s){const{areReqParamsEmpty:n,errorMessage:o}=j(["username","email","password"],e.body);n?(t.status(400),t.json({error:I(o)})):s()}),(async function(e,t,s){const{email:n}=e.body;await Y(n)?(t.status(400),t.json({error:"Email already exists."})):s()}),(function(e,t,s){const{username:n}=e.body,o=[];/\S/g.test(n)||o.push("must not contain only whitespace"),n.length>15&&o.push("must not exceed 15 characters"),0===o.length?s():(t.status(400),t.json({error:`Username ${q(o)}.`}))}),(function(e,t,s){const{email:n}=e.body;/^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/.test(n)?s():(t.status(400),t.json({error:"Email is invalid."}))}),(function(e,t,s){const{password:n}=e.body,o=[];/\s/g.test(n)&&o.push("must not contain any whitespace"),n.length<8&&o.push("length must be at least 8 characters"),n.length>50&&o.push("length must not exceed 50 characters"),0===o.length?s():(t.status(400),t.json({error:`Password ${q(o)}.`}))}),(async function(e,t){const{username:s,email:n,password:o}=e.body,r={username:s,email:n,password:await G.a.hash(o,10)};try{const s=await new W(r).save();e.session.user={userId:s._id},t.status(201),t.json({message:"User added.",newUser:s})}catch(e){t.status(501),t.json({error:"Could not add user."})}})),se.route("/login").post(ee,(function(e,t,s){const{doesReqHaveRequiredParams:n,errorMessage:o}=w(["email","password"],e.body);n?s():(t.status(400),t.json({error:I(o)}))}),(function(e,t,s){const{areReqParamsEmpty:n,errorMessage:o}=j(["email","password"],e.body);n?(t.status(400),t.json({error:I(o)})):s()}),(async function(e,t,s){const{email:n}=e.body;await Y(n)?s():(t.status(400),t.json({error:"Email is incorrect."}))}),(async function(e,t,s){const{email:n,password:o}=e.body,r=await W.findOne({email:n});await G.a.compare(o,r.password)?s():(t.status(400),t.json({error:"Password is incorrect."}))}),(async function(e,t){const{email:s}=e.body;try{const n=await W.findOne({email:s});e.session.user={userId:n._id},t.status(200),t.json({message:"User logged in.",user:n})}catch(e){t.status(501),t.json({error:"Could not login user."})}})),se.route("/logout").post(te,(function(e,t){const{session:s}=e,{user:{userId:n}}=s;s.destroy(e=>{e?(t.status(500),t.json({error:"Something went wrong."})):(t.clearCookie(X),t.status(200),t.json({message:"User logged out.",userId:n}))})})),se.route("/exams").get(te,(async function(e,t){const{session:{user:{userId:s}}}=e;try{const e=await T.find({creator:s});t.status(200),t.json({message:"Exams found.",exams:e})}catch(e){t.status(501),t.json({error:"Could not get exams."})}}));var ne=se;i.a.config();const{SESS_NAME:oe,SESS_SECRET:re,SESS_LIFETIME:ae,DB:ue,NODE_ENV:ie}=process.env,ce=o()();ce.use(f()());const de=ue;a.a.connect(de,{dbName:"exam-creator",useNewUrlParser:!0,useUnifiedTopology:!0}),ce.use(m.a.json());const pe=b()(d.a);ce.use(d()({name:oe,secret:re,saveUninitialized:!1,resave:!1,store:new pe({mongooseConnection:a.a.connection,ttl:parseInt(ae,10)/1e3}),cookie:{sameSite:!0,secure:"production"===ie,maxAge:parseInt(ae,10)}})),ce.use("/api/v1/exams",B),ce.use("/api/v1/exams/questions",Q),ce.use("/api/v1/exams/students",L),ce.use("/api/v1/users",ne);var me=ce;const ye=process.env.PORT||8080;me.listen(ye);t.default=me}]);